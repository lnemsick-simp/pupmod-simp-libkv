# vim: set expandtab ts=2 sw=2:
---
functions:
  get:
    :examplereturn: data
    :retval:
#FIXME should this be NotUndef?  When would nil be an allowed value?
      :type: 'Any'
      :description: 'The value in the underlying backing store'
    :description: 'Connects to the backend and retrieves the data stored at **key**'
    :softfail_value: nil
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
            :description:
              'FILL-ME-IN'
      v1:
        :args:
          - :type: 'String[1]'
            :name: 'key'
            :description: 'The key to get'
    :validation:
      - "unless params.key?('key')\n
           raise ArgumentError.new(\"ERROR: libkv::get - Missing 'key' param\")\n
         end"
      - "if params['key'].strip.empty?\n
           raise ArgumentError.new(\"ERROR: libkv::get - Invalid 'key' param '#{params['key']}'\")\n
         end"
    :examples:
      - "
         $database_server = libkv::get(\"/database/${facts['fqdn']}\")\n
         class { 'wordpress':\n
         \tdb_host => $database_server,\n
         }"
  put:
    :examplereturn: succeeded
    :retval:
      :type: 'Boolean'
      :description: 'Whether the backend set operation succeeded'
    :description: 'Sets the data at `key` to the specified `value`'
    :softfail_value: 'false'
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
            :description:
              'FILL-ME-IN'
      v1:
        :args:
          - :type: 'String[1]'
            :name: 'key'
            :description: 'The key to be set'
          - :type: 'NotUndef'
            :name: 'value'
            :description: 'The value of the key'
    :validation:
      "unless params.key?('key') && !params['key'].strip.empty? \n
         raise ArgumentError.new(\"ERROR: libkv::put - Missing valid 'key' param')
       end"
    :examples:
      - "libkv::put(\"/hosts/${facts['fqdn']}\", \"${facts['ipaddress']}\")"
  delete:
    :examplereturn: succeeded
    :retval:
      :type: 'Boolean'
      :description: 'Whether the backend operation succeeded'
    :description: 'Deletes the specified `key`. Must be a single key'
    :softfail_value: 'false'
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
            :description:
              'FILL-ME-IN'
      v1:
        :args:
          - :type: 'String[1]'
            :name: 'key'
            :description: 'The key to be deleted'
    :validation:
      "unless params.key?('key') && !params['key'].strip.empty? \n
         raise ArgumentError.new(\"ERROR: libkv::delete - Missing valid 'key' param')
       end"
    :examples:
      - "$response = libkv::delete(\"/hosts/${facts['fqdn']}\")"
  exists:
    :examplereturn: exists
    :retval:
      :type: 'Boolean'
      :description: 'Whether the `key` exists in the backend'
    :description: 'Returns true if `key` exists'
    :softfail_value: nil
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
            :description:
              'FILL-ME-IN'
      v1:
        :args:
          - :type: 'String[1]'
            :name: 'key'
            :description: 'The key to check'
    :validation:
      "unless params.key?('key') && !params['key'].strip.empty? \n
         raise ArgumentError.new(\"ERROR: libkv::exists - Missing valid 'key' param')
       end"
    :examples:
      - "
        if libkv::exists(\"/hosts/${facts['fqdn']}\") {\n
        \tnotify { \"/hosts/${facts['fqdn']} exists\": }\n
        }"
  list:
    :examplereturn: list
    :retval:
      :type: 'Hash'
      :description: 'Hash of key/value pairs'
    :description: 'Lists all keys in the folder named `key`'
    :softfail_value: "{}"
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
            :description:
              'FILL-ME-IN'
      v1:
        :args:
          - :type: 'String[1]'
            :name: 'key'
            :description: 'The folder to list'
    :validation:
      "unless params.key?('key') && !params['key'].strip.empty? \n
         raise ArgumentError.new(\"ERROR: libkv::list - Missing valid 'key' param')
       end"
    :examples:
      - "
        $list = libkv::list('/hosts')\n
        $list.each |String $host, String $ip| {\n
        \thost { $host:\n
        \t\tip => $ip,\n
        \t}\n
        }"
  deletetree:
    :examplereturn: succeeded
    :retval:
      :type: 'Boolean'
      :description: 'Whether the backend folder deletion operation succeeded'
    :description: 'Deletes the whole folder named `key`. This action is inherently unsafe.'
    :softfail_value: 'false'
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
            :description:
              'FILL-ME-IN'
      v1:
        :args:
          - :type: 'String[1]'
            :name: 'key'
            :description: 'The folder to delete'
    :validation:
      "unless params.key?('key') && !params['key'].strip.empty? \n
         raise ArgumentError.new(\"ERROR: libkv::deletetree - Missing valid 'key' param')
       end"
    :examples:
      - "$response = libkv::deletetree('/hosts')"
  atomic_create:
    :examplereturn: succeeded
    :retval:
      :type: 'Boolean'
      :description: 'Whether the backend create operation succeeded'
    :description: 'Store `value` in `key` atomically, but only if key does not already exist'
    :softfail_value: "{}"
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
            :description:
              'FILL-ME-IN'
      v1:
        :args:
          - :type: 'String[1]'
            :name: 'key'
            :description: 'The key to be created'
          - :type: 'NotUndef'
            :name: 'value'
            :description: 'The value of the key'
    :validation:
      "unless params.key?('key') && !params['key'].strip.empty? \n
         raise ArgumentError.new(\"ERROR: libkv::get - Missing valid 'key' param')
       end"
    :examples:
      - "
         $id = rand(0,2048)\n
         $result = libkv::atomic_create(\"/serverids/${facts['fqdn']}\", $id)\n
         if ($result == false) {\n
         \t$serverid = libkv::get(\"/serverids/${facts['fqdn']}\")\n
         } else {\n
         \t$serverid = $id\n
         }\n
         notify(\"the server id of ${serverid} is idempotent!\")
        "
  atomic_delete:
    :examplereturn: succeeded
    :retval:
      :type: 'Boolean'
      :description: 'Whether the backend delete operation succeeded'
    :description: 'Delete `key`, but only if key still matches the value of `previous`'
    :softfail_value: "{}"
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
            :description:
              'FILL-ME-IN'
      v1:
        :args:
          - :type: 'String[1]'
            :name: 'key'
            :description: 'The key to delete'
          - :type: 'Hash'
            :name: 'previous'
            :description: 'The value in the underlying backing store'
    :validation:
      - "unless params.key?('key')\n
           raise ArgumentError.new(\"ERROR: libkv::get - Missing 'key' param\")
         end"
      - "if params['key'].strip.empty?\n
           raise ArgumentError.new(\"ERROR: libkv::get - Invalid 'key' param '#{params['key']}'\")
         end"
    :examples:
      - "
         $previous = libkv::atomic_get(\"/env/${facts['fqdn']}\")\n
         $result = libkv::atomic_delete(\"/env/${facts['fqdn']}\", $previous)
        "
  atomic_get:
    :examplereturn: previous
    :retval:
      :type: 'Hash'
      :description: 'Hash containing the value in the underlying backing store'
    :description: 'Get the value of key, but return it in a hash suitable for use with other atomic functions'
    :softfail_value: "{}"
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
            :description:
              'FILL-ME-IN'
      v1:
        :args:
          - :type: 'String[1]'
            :name: 'key'
            :description: 'The key whose value is to be retreived'
    :validation:
      "unless params.key?('key') && !params['key'].strip.empty? \n
         raise ArgumentError.new(\"ERROR: libkv::get - Missing valid 'key' param')
       end"
    :examples:
      - "
         $previous = libkv::atomic_get(\"/env/${facts['fqdn']}\")\n
         notify { \"previous value is ${previous['value']}\": }
        "
  atomic_put:
    :examplereturn: succeeded
    :retval:
      :type: 'Boolean'
      :description: 'Whether the backend set operation succeeded'
    :description: 'Set `key` to `value`, but only if the key is still set to `previous`'
    :softfail_value: "{}"
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
            :description:
              'FILL-ME-IN'
      v1:
        :args:
          - :type: 'String[1]'
            :name: 'key'
            :description: 'The key to be set'
          - :type: 'NotUndef'
            :name: 'value'
            :description: 'The value of the key'
          - :type: 'Hash'
            :name: 'previous'
            :description: 'Hash containing the previous value of the key'
    :validation:
      "unless params.key?('key') && !params['key'].strip.empty? \n
         raise ArgumentError.new(\"ERROR: libkv::get - Missing valid 'key' param')
       end"
    :examples:
      - "
         $newvalue = 'new'\n
         $previous = libkv::atomic_get(\"/env/${facts['fqdn']}\")\n
         $result = libkv::atomic_put(\"/env/${facts['fqdn']}\", $newvalue, $previous)\n
         if ($result == true) {\n
         \t$real = $newvalue\n
         } else {\n
         \t$real = libkv::get(\"/env/${facts['fqdn']}\")\n
         }\n
         notify { \"I updated to ${real} atomically!\": }
        "
  atomic_list:
    :examplereturn: list
    :retval:
      :type: 'Hash'
      :description: 'Hash of key/value pairs'
    :description: 'List all keys in folder `key`, but return them in a format suitable for other atomic functions'
    :softfail_value: "{}"
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
            :description:
              'FILL-ME-IN'
      v1:
        :args:
          - :type: 'String[1]'
            :name: 'key'
            :description: 'The folder to list'
    :validation:
      "unless params.key?('key') && !params['key'].strip.empty? \n
         raise ArgumentError.new(\"ERROR: libkv::get - Missing valid 'key' param')
       end"
    :examples:
      - "# Add a host resource for everything under /hosts\n\n
        $list = libkv::atomic_list('/hosts')\n
        $list.each |String $host, Hash $data| {\n
        \thost { $host:\n
        \t\tip => $data['value'],\n
        \t}\n
        }"
      - "# For each host in /hosts, atomically update the value to 'newip'\n\n
        $list = libkv::atomic_list('/hosts')\n
        $list.each |String $host, Hash $data| {\n
        \tlibkv::atomic_put(\"/hosts/${host}\", 'newip', $data)\n
        }"
  empty_value:
    :examplereturn: empty_value
    :retval:
      :type: 'Hash'
      :description: 'Empty hash representing an empty value'
    :description: 'Return an hash suitable for other atomic functions, that represents an empty value'
    :softfail_value: nil
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
    :allow_empty: true
    :examples:
      - "
         $empty = libkv::empty_value()\n
         $result = libkv::atomic_get('/some/key')\n
         if ($result == $empty) {\n
         \tnotify { \"/some/key doesn't exist\": }\n
         }
        "
  info:
    :examplereturn: provider_information
    :retval:
      :type: 'Hash'
      :description: 'Provider information hash'
    :description: 'Return a hash of informtion on the underlying provider. Provider specific'
    :softfail_value: "{}"
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
    :allow_empty: true
    :examples:
      - "
         $info = libkv::info()\n
         notify { \"libkv connection is: ${info}\": }
        "
  supports:
    :examplereturn: supported_functions
    :retval:
      :type: 'Array'
      :description: 'Array of provider supported functions'
    :description: 'Return an array of all supported functions'
    :softfail_value: "[]"
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
    :allow_empty: true
    :examples:
      - "
         $supports = libkv::supports()\n
         if ($supports in 'atomic_get') {\n
         \tlibkv::atomic_get('/some/key')\n
         } else {\n
         \tlibkv::get('/some/key')\n
         }
        "
  pop_error:
#    :reserved: true
    :examplereturn: error_string
    :retval:
      :type: 'String'
      :description: "Provider's error message for the last call"
    :description: 'Return the error message for the last call'
    :softfail_value: "''"
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
    :allow_empty: true
    :examples:
      - "
        unless libkv::put(\"/hosts/${facts['fqdn']}\", \"${facts['ipaddress']}\") {\n
        \t$put_err_msg = libkv::pop_error()\n
        \tnotify { \"Setting /hosts/${facts['fqdn']} failed: ${put_err_msg}\": }\n
        }
        "
  provider:
    :examplereturn: provider_name
    :retval:
      :type: 'String'
      :description: 'Provider name'
    :description: 'Return the name of the current provider'
    :softfail_value: "''"
    :signatures:
      full_hash:
        :args:
          - :type: 'Hash'
            :name: 'params'
    :allow_empty: true
    :examples:
      - "
         $provider = libkv::provider()\n
         notify { \"libkv connection is: ${provider}\": }
        "
  watch:
    :unsupported: true
  watchtree:
    :unsupported: true
  newlock:
    :unsupported: true

